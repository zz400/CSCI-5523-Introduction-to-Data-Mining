import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * Use List of List to store binary sparse matrix
 */

/**
 * @author Zhengyang Zhao
 * Oct 18, 2018
 */

public class SparseList {
	
	static int countInstance = 0;
	static int nnz = FileLoader.numRec;  // number of non-zero entries in the matrix
	static int rowNum = FileLoader.maxTransID + 1;
	static int colNum = FileLoader.maxItemID + 1;
	LinkedList<Integer> nonZeroCols = new LinkedList<>();
	HashMap<Integer, ArrayList<Integer>> colMap = new HashMap<>();
	
	SparseList(List<List<Integer>> db) {
		// db: two-column arrayList listing the cells with value "1".
		// 		col0 lists row indexes of non-zero entries; 
		// 		col1 lists column indexes of non-zero entries.
		
		countInstance++;
		nnz = FileLoader.numRec;  // number of non-zero entries in the matrix
		rowNum = FileLoader.maxTransID + 1;
		colNum = FileLoader.maxItemID + 1;
		
		for (int i = 0; i < colNum; i++) {
			nonZeroCols.add(i);
		}
		
		for (int i = 0; i < db.get(0).size(); i++) {
			int rowIndex = db.get(0).get(i);
			int colIndex = db.get(1).get(i);
			if (colMap.get(colIndex) == null) {
				colMap.put(colIndex, new ArrayList<Integer>());
			}
			colMap.get(colIndex).add(rowIndex);
		}
	}
	
	SparseList(SparseList another) {
		countInstance++;
		for (int i = 0; i < another.nonZeroCols.size(); i++) {
			nonZeroCols.add(another.nonZeroCols.get(i));
		}
		colMap = another.colMap;
	}
	
	public void updateColList(List<Integer> fromRows, int minSup) {
		HashSet<Integer> rowSet = new HashSet<>();
		for (int i : fromRows) {
			rowSet.add(i);
		}
		
		HashMap<Integer, ArrayList<Integer>> colMapOfFather = colMap;
		colMap = new HashMap<>();
		
		Iterator<Integer> iter = nonZeroCols.iterator();
		while (iter.hasNext()) {
			int colIndex = iter.next();
			int count = 0;
			ArrayList<Integer> colOfFather = colMapOfFather.get(colIndex);
			ArrayList<Integer> col = new ArrayList<>();
			
			for (int rowIndex : colOfFather) {
				if (rowSet.contains(rowIndex)) {
					count++;
					col.add(rowIndex);
				} 
			}
			
			if (count < minSup) {
				iter.remove();
			} else {
				colMap.put(colIndex, col);
			}
		}
	}
	
	public void doProjection(int column, int minSup) {

		if (column == 0) {
			Iterator<Integer> iter = nonZeroCols.iterator();
			while (iter.hasNext()) {
				int colIndex = iter.next();
				if (!colMap.containsKey(colIndex)) {
					iter.remove();
				} else if (colMap.get(colIndex).size() < minSup) {
					colMap.remove(colIndex);
					iter.remove();
				} 
			}
			
		} else {
			while (nonZeroCols.size() != 0 && nonZeroCols.get(0) <= column) {
				nonZeroCols.removeFirst();
			}
			
			if (nonZeroCols.size() != 0) {
				// Select rows and Update listOfCols (pruning is envolved):
				List<Integer> keepRows = colMap.get(column);
				updateColList(keepRows, minSup);
			}
		}
	}
	
	public static void main(String[] args) {
		int option = 1;
		int minSup = 5;
		String filename = "src/toy";
		FileLoader.runBatch(filename, option);
		
		SparseList sList = new SparseList(FileLoader.dbReordered);
		sList.doProjection(0, minSup);
		System.out.println("nonZeroCols: " + sList.nonZeroCols);
		System.out.println("\n");
	}

}
	
